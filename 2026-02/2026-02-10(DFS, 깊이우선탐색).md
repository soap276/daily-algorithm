## DFS
``` python
def dfs(graph, v, visited):

    # 현재 노드 방문 처리
    visited[v] = True
    print(v, end = ' ')
    # 현재 노드와 연결된 다른 노드 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)

graph = [[],
        [2, 3, 8],
        [1, 7],
        [1, 4, 5],
        [3, 5],
        [3, 4],
        [7],
        [2, 6, 8],
        [1, 7]
        ]

visited = [False] * 9

dfs(graph, 1, visited)
```
``` python
# 인접 행렬
# A = 0, B = 1,,,, G = 6
# 정점의 개수는 N = 7 개

# adj_matrix = []
# 1번 정점과 2번 정점이 인접 (다른 정점을 거치지 않고 바로 연결)
# adj_matrix[1][2] = 1
# adj_matrix[2][1] = 0 (유향 그래프인 경우 역방향 x)
# 3번 정점과 4번 정점이 인접하지 않음
# adj_matrix[3][4] = 0
adj_matrix = [[0, 1, 1, 0, 0, 0, 0], # A
              [1, 0, 0, 1, 1, 0, 0], # B
              [1, 0, 0, 0, 1, 0, 0], # C
              [0, 1, 0, 0, 0, 1, 0], # D
              [0, 1, 1, 0, 0, 1, 0], # E
              [0, 0, 0, 1, 1, 0, 1], # F
              [0, 0, 0, 0, 0, 1, 0]] # G

# 인접 행렬로 그래프를 나타낸 상태에서 깊이 우선 탐색
# s : 탐색을 시작하는 정점 번호
# v : 정점의 개수
def dfs(s, V):
    # dfs: 깊이우선탐색
    # 그래프의 모든 정점을 빠짐없이 한번씩 모두 탐색
    # 내가 이전에 방문 했는지 안했는지 여부를 확인
    visited = [0] * V
    # visited[5] == 1 => 5번 정점을 방문한적이 있다.
    # visited[6] == 0 => 6번 정점을 방문한적이 없다

    # 돌아올 길을 저장(기억)할 스택
    stack = []

    # 시작정점 s를 방문했다 처리
    visited[s] = 1
    print(s)

    # 현재 내가 방문하고 있는 정점 번호 v
    v = s

    # 그래프 탐색 시작
    while True:
        # 현재 내가 있는 정점 번호는 v
        # v와 인접한 정점(w)이 있나 없나 확인 => 있다면 이전에 방문 했나 안했나 확인
        # 방문 가능하면 방문한다.

        for w in range(V):
            # v와 w가 인접하고 w를 이전에 방문한적이 없으면 방문한다.
            if adj_matrix[v][w] and not visited[w]:
                # w는 갈 수 있다.
                # 방문처리, w 정점에서 필요한 작업을 한다.
                # w에서 더이상 갈 길이 없으면 v로 돌아와야 하니
                # v를 스택에 저장
                stack.append(v)
                # w를 방문했다고 처리
                visited[w] = 1
                # w 정점에서 할일
                print(w)
                # w로 이동해서 위에서 했던 탐색을 반복
                v = w
                # 바뀐 v에서 새로운 탐색을 해야 하기 때문에 break
                break
        else:
            # 반복 중에 break 한적이 없다 => 이동가능한 다른 정점이 없다.
            # 이전 길로 돌아가기 (스택에서 돌아갈 정점번호 꺼내기)
            if stack:
                # 스택에서 돌아갈 곳 꺼내서 현재 위치로 바꾸기
                stack.pop()
            else:
                # 스택이 비었다면 돌아갈곳이 없다. => 모든 정점 탐색 완료
                break # for while

# 0번 정점에서 시작하고 정점의 개수는 7개
dfs(0, 7)
```
``` python
## 과제 그래프 경로 문제
T = int(input())
for tc in range(1, T+1):
    # V, E = 정점의 개수, 간선의 개수
    V, E = map(int, input().split())
    
    # 인접 행렬
    # adj_m[1][2] == 1 => 1번에서 2번가는길 o
    # 정점 번호가 1~V 이므로 (V+1) 크기로 생성
    adj_m = [[0] * (V+1) for _ in range(V+1)]
    
    # 그래프 정보 입력
    # 출발-도착 정점 쌍(간선) 정보가 E개 입력으로 들어온다.
    for i in range(E):
        s, e = map(int, input().split())
        adj_m[s][e] = 1
        # adj_m[e][s] = 1 요건 안됨 (무향 그래프에서 사용)
    
    # 테스트케이스 입력 마지막에 출발 정점 번호, 목표 정점 번호
    S, G = map(int, input().split())
    
    # S에서 출발하는 DFS 탐색, 탐색중 G를 만나면 탐색 종료

    ### DFS
    def dfs(S, V):
        # 방문 여부 체크, 처음에는 다 0으로 설정
        visited = [0] * (V+1)
        # 되돌아갈 경로를 저장할 스택
        stack = []
        # 시작 정렬 방문 처리
        visited[S] = 1
        # 현재 탐색중인 정렬
        T = S
        

        while True:
            # 현재 정점 T와 연결된 정점들 탐색
            for w in range(1, V+1):
                # T-> w로 갈 수 있고 아직 방문하지 않았을 때
                if adj_m[T][w] and not visited[w]:
                    # 다시 돌아오기 위해 현재위치는 스택에 저장
                    stack.append(T)
                    # 새 정점 w 방문
                    visited[w] = 1
                    # 탐색 위치를 w로 이동
                    T = w
                    
                    # G를 만나면 즉시 종료
                    if T == G:
                        return 1
                    break
            else:
                # 더이상 갈 수 있는 인접 정점이 없을 때
                if stack:
                    # 이전 정점으로 되돌아감
                    T = stack.pop()
                else:
                    # 되돌아갈수 있는 정점이 없을 때 탐색 종료
                    break
        
        return 0

    print(f'#{tc} {dfs(S, V)}')
```

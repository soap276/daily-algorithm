``` python
# DFS 메서드 정의
def dfs(graph, v, visited):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end=' ')

    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)

    # 각 노드가 연결된 정보를 리스트 자료형으로 표현 (2차원 리스트)
    graph = [
        [], 
        [2, 3, 8], 
        [1, 7],
        [1, 4, 5],
        [3, 5],
        [3, 4],
        [7],
        [2, 6, 8],
        [1, 7]
    ]

    # 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
    visited = [False] * 9

    # 정의된 DFS 함수 호출
    dfs(graph, 1, visited)



# 부분 집합
arr = list(map(int, input().split()))
n = len(arr)
answer = 'NO'
for i in range(1, 1<<n): # 1부터 인 것 = 공집합을 제외한다. 
    s = 0 # 부분집합의 합
    for j in range(n):
        if i & (1<<j):
            s += arr[j] 
    if s == 0:
        answer = 'YES'
        break
print(answer)



## 순차 검색 (일렬로 되어 있는 자료를 순서대로 검색하는 방법)
# 정렬되어 있지 않은 경우 -> 첫번째 원소부터 순서대로 검색대상과 키 값이 같은 원소가 있는지 비교
# 찾고자 하는 원소의 순서에 따라 비교 횟수 결정. 검색 실패 시 마지막 원소까지 비교하므로 평균 비교 횟수 n
key = 2
def find_key(arr, n, key):
    for i in range(n):
        if arr[i] == key:
            return i # 인덱스 반환
    return -1

def sequential_search(a, n, key):
    i = 0
    while i < n and a[i] != key: # 무조건 범위 먼저, 두 조건의 위치를 바꾸면 결과 이상
        i += 1
    if i < n:
        return i
    else:
        return -1


# 순차 검색 - 정렬되어 있는 경우 -> 오름차순 정렬. 검색 실패를 반환하는 경우에도 평균 비교 횟수가 반으로 줄어듬 (n+1)/2
def sequential_search2(a, n, key):
    for i in range(n):
        if a[i] == key:
            return i
        elif a[i]> key:
            return -1
    return -1

def sequential_search2(a, n, key):
    i = 0
    while i < n and a[i] < key:
        i+=1
    if i < n and a[i] == key:
        return i
    else:
        return -1


# 이진 검색: 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색 위치를 결정, 자료는 정렬된 상태여야 함
# 자료에 삽입이나 삭제가 발생했을 때 상태를 항상 정렬 상태로 유지하는 추가 작업 필요

def binary_search(a, N, key): # key를 찾으면 인덱스, 실패하면 -1 반환
    start = 0
    end = N-1
    while start <= end :
        middle = (start + end) // 2
        if a[middle] == key: # 검색 성공
            return middle
        elif a[middle] > key: # 찾는 값보다 크면
            end = middle - 1 # 왼쪽 구간 선택
        else:
            start = middle + 1 # 오른쪽 구간 선택

    return -1 # 검색 실패


# 선택 정렬 (vs 버블정렬)
# 주어진 리스트에서 최솟값(최솟값의 위치)을 찾고 리스트의 맨 앞에 위치한 값과 교환
def selection_sort(a, N):
    for i in range(N-1): # 정렬 구간의 시작 인덱스
        min_idx = i # 첫 원소를 최솟값으로 가정
        for j in range(i+1, N):
            if a[min_idx] > a[j]: # 최솟값의 인덱스 갱신
                min_idx = j
        a[i], a[min_idx] = a[min_idx], a[i] # 구간 최솟값을 구간 맨 앞으로

# 카운팅 정렬이 수행시간 제일 짧음 but k가 비교적 작은 때만 가능

# 셀렉션 알고리즘: 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
def select(arr, k):
    for i in range(0, k):
        min_index = i
        for j in range(i+1, len(arr)):
            if arr[min_index] > arr[j]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr[k-1]


## 이진 탐색

T = int(input())
# 여러개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
for test_case in range(1, T + 1):
    P, A, B = map(int, input().split())
    # P: 총 페이지수
    # A: A가 찾아야 하는 페이지
    # B: B가 찾아야 하는 페이지

    # 문제에서 원하는 답 = 누가 더 빨리찾느냐(승자)
    winner = ""
    # A의 이진탐색 범위
    a_start, a_end = 1, P
    # B의 이진탐색 범위
    b_start, b_end = 1, P

    # A와 B가 번갈아 가며 가운데를 찍는다.
    while True:
        # A가 원하는 페이지를 찾았는가 여부
        a_find = False
        # B가 원하는 페이지를 찾았는가 여부
        b_find = False
        # A 또는 B가 원하는 페이지를 찾으면 종료 break

        # A가 가운데 페이지 찍어보기
        mid = (a_start + a_end) // 2
        # 가운데 찍었는데 원하는 페이지 찾은경우
        if mid == A:
            a_find = True
        # 가운데 찍었는데 원하는 페이지보다 작은경우
        elif mid > A:
                a_end = mid
        # 가운데 찍었는데 원하는 페이지보다 큰 경우
        else:
                a_start = mid
        
        # B가 가운데 페이지 찍어보기
        mid = (b_start + b_end) // 2
        # 가운데 찍었는데 원하는 페이지 찾은경우
        if mid == B:
            b_find = True
        # 가운데 찍었는데 원하는 페이지보다 작은경우
        elif mid > B:
                b_end = mid
        # 가운데 찍었는데 원하는 페이지보다 큰 경우
        else:
                b_start = mid
    
        # A나 B가 원하는 페이지를 찾았으면 승자 결정 하고 
        # break
        # A가 승
        if a_find and not b_find:
            winner = 'A'
            break
        # B가 승
        elif b_find and not a_find:
            winner = 'B'
            break
        # A, B 둘다 찾아서 무승부
        elif a_find and b_find:
            winner = 0
            break

    print(f'#{test_case} {winner}')
       


# 특별한 정렬
T = int(input())
# 여러개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
for test_case in range(1, T + 1):
    N = int(input())
    arr = list(map(int, input().split()))

    # 인덱스가 짝수 => 큰애들
    # 인덱스가 홀수 => 작은애들

    # 앞에서부터 10개의 자리만 확장하면 된다. 
    for i in range(10):
        # 큰애들 or 작은애들의 위치를 i라고 하자
        idx = i
        for j in range(i+1, N):
            # i가 짝수면 => 큰애 위치
            if i % 2 == 0 and arr[j] > arr[idx]:
                # j위치에 있는 원소가 이전 최대값보다 크면 갱신
                idx = j

            # i가 홀수면 => 작은애 위치 찾기
            if i % 2 == 1 and arr[j] < arr[idx]:
                # j위치에 있는 원소가 이전 최소값보다 작으면 갱신
                idx = j
        # i자리에 올 원소는 idx위치에 있는 원소 (최대값 or 최소값)
        arr[i], arr[idx] = arr[idx], arr[i]

    #  앞에서부터 10개만 잘라서 출력
    print(f'#{test_case}', *arr[:10])



# 사다리 타기
# 여러개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
import sys
sys.stdin = open("input (3).txt", "r")


for test_case in range(1, 11):
    test_num = int(input())
    ladder = [list(map(int, input().split())) for _ in range(100)]
 
    # 사다리 정보를 모두 알고 있기 때문에
    # 당첨지점에서 올라오면 어디서 시작해야 당첨으로 갈지 알 수 있다.
 
    # 2의 위치 찾기
    x = 99
    y = 0
    for i in range(100):
        if ladder[99][i] == 2:
            y = i
            break
 
    # 아래에서 위로 가는 사다리타기는 방향이 3개 (상, 좌, 우)
    # 위로 가는 방향보다 좌 우 방향이 우선순위가 높다.
    # 좌우 먼저 탐색하고 갈 수 있으면 이동, 좌우 길 없으면 위로 이동
 
    # dx = [0, 0, 1]
    # dy = [-1, 1, 0]
 
    while x > 0:
 
        # 이동하는 코드
 
        # 현재위치 (x, y)에서 3방향 탐색
 
        # 다음위치 (nr, nc) 계산
        # 이 다음위치가 이동가능한 위치인지 확인
        # 1. 이동 가능한 인덱스 범위
        # 2. 사다리가 있는 칸인지 확인
        # 3. 왔던 길인지 확인(왔던 길이면 다시 안가도록)
 
        # 이동가능하면 현재 위치 (r, c)를 (nr, nc)로 변경(이동)
        # 왔던 사다리는 지워버리면 됩니다. (0으로 바꿔버리면 됨=> ladder[r][c] = 0)
 
        # 나머지 방향 탐색 중단
 
 
 
        # 왼쪽 길이면 왼쪽 끝까지
        if y > 0 and ladder[x][y - 1] == 1:
            while y > 0 and ladder[x][y - 1] == 1:
                y -= 1
            x -= 1
 
        # 오른쪽 길이면 오른쪽 끝까지
        elif y < 99 and ladder[x][y + 1] == 1:
            while y < 99 and ladder[x][y + 1] == 1:
                y += 1
            x -= 1
 
        # 오른쪽 길, 왼쪽 길 둘 다 없으면 위로
        else:
            x -= 1
 
    print(f'#{test_case} {y}')

```


            
            

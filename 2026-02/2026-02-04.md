``` python
# 지그재그 순회
for i in range(n):
    for j in range(m):
        f(array[i][j + (m-1-2*j) * (i%2)])

# 델타를 활용한 2차원 배열 탐색
# 인덱스 (i, j)인 칸의 상하좌우 간 (ni, nj)
# 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
for i in range(N): # NxN 배열
    for j in range(N):
        for di, dj in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
            ni, nj = i+di, j+dj
# 상하좌우 k칸의 합계 중 최댓값 (k=2)
max_v = 0
for i in range(N): # NxN 배열
    for j in range(N):
        s = arr[i][j]
        for di, dj in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
            for c in range(1, k+1):
                ni, nj = i+di*c, j+dj*c
                if 0<=ni<N and 0<=nj<N:
                    s+= arr[ni][nj]
        if max_v < s:
            max_v = s

# 전치 행렬
# i: 행의 크기, j: 열의 크기
for i in range(3):
    for j in range(3):
        if i < j:
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]

# 각 원소가 부분집합에 포함되었는지를 loop를 이용하여 확인하고 부분집합을 생성하는 방법
def print_subset(bit):
    A = [1, 2, 3, 4]
    for i in range(4):
        if bit[i] == 1:
            print(A[i], end=' ')
    print()

bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
                print_subset(bit)

# 비트 연산으로 부분집합을 생성하는 방법
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)

for i in range(1<<n): # 2의 N승 -> 부분집합의 개수, <<: 1을 왼쪽으로 j칸 이동시키는 것
    subset = [] 
    for j in range(n): # 원소의 수만큼 비트를 비교함
        if i & (1<<j): # i의 j번 비트가 1인 경우
            subset.append(arr[j])
            print(arr[j], end=', ') # j번 원소 출력
    print()
print()



  
## 2차원 배열 합
T = int(input())
# 여러개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
for test_case in range(1, T + 1):
    N, M = map(int, input().split())
    arr = [list(map(int, input().split())) for _ in range(N)]
    s = 0
    for i in range(N):
        for j in range(M):
            s += arr[i][j]

    print(f'#{test_case} {s}')



## 부분집합의 합
T = int(input())
# 여러개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
for test_case in range(1, T + 1): # 2의 N승 -> 부분집합의 개수, <<: 1을 왼쪽으로 j칸 이동시키는 것
    A = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
    A_len = len(A)
    N, K = map(int, input().split())
    count = 0
    for i in range(1<<A_len): # 2의 N승 -> 부분집합의 개수, <<: 1을 왼쪽으로 j칸 이동시키는 것
        subset = []
        for j in range(A_len): # 원소의 수만큼 비트를 비교함
            if i & (1 << j): # i의 j번 비트가 1인 경우
                subset.append(A[j]) # j번 원소 추가
        if len(subset) == N and sum(subset) == K:
            count += 1

    print(f'#{test_case} {count}')


## 풍선 팡2
T = int(input())
# 여러개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
for test_case in range(1, T + 1):
    N, M = map(int, input().split())
    matrix = [list(map(int, input().split())) for _ in range(N)]
    # 문제에서 원하는 답 (상하좌우 품선 터졌을 때 최대 꽃가루 개수)
    max_pollen = 0

    # 상하좌우 탐색용 델타 배열
    di = [-1, 1, 0, 0]
    dj = [0, 0, -1, 1]

    # 행 우선 순회
    for i in range(N):
        for j in range(M):
            # (i, j) 위치에서 상하좌우 풍선 터뜨려서 꽃가루 합 구하기
            # 4방향으로 이동하니까 이동 4번 반복

            # (i, j)위치에 있던 꽃가루 개수
            cnt = matrix[i][j]

            # 상하좌우로 뻗어나갈 수 있는 최대 칸 수 = 현재 위치 꽃가루
            k = matrix[i][j]

            for d in range(4):
                for c in range(1, k+1):
                    # (i, j) 에서 c 칸 이동한 좌표 (ni, nj)
                    ni = i + di[d] * c
                    nj = j + dj[d] * c
                    # (ni, nj)가 유효한 좌표인지 검사
                    if 0<=ni<N and 0<=nj<M:
                        cnt += matrix[ni][nj]
            
            # 상하좌우 탐색이 끝나고 최댓값 갱신
            if cnt > max_pollen:
                max_pollen = cnt
    # 모든 위치에서 최대값 계산 후 답 출력
    print(f'#{test_case} {max_pollen}')
        

## sum
# T = int(input())
# 여러개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
for test_case in range(1, 11):
    num_testcase = int(input())
    matrix = [list(map(int, input().split())) for _ in range(100)]
 
    def row_sum(matrix): # 행끼리의 합 중에 최대값 출력하는 함수
        s_row_list = []
        for i in range(100):
            s_row = 0
            for k in range(100):
                s_row += matrix[i][k]
            s_row_list.append(s_row)
        return max(s_row_list)
 
    def col_sum(matrix): # 열끼리의 합 중에 최대값 출력하는 함수
        s_col_list = []
        for k in range(100):
            s_col = 0
            for i in range(100):
                s_col += matrix[i][k]
            s_col_list.append(s_col)
        return max(s_col_list)
 
    def diagonal(matrix): # 대각선끼리의 합 중에 최대값 출력하는 함수
        i,j = 0, 0
        a = matrix[i][j]
        s_diagonal = []
        # for di, dj in [1, 1]:
        for k in range(1, 100): # 오른쪽 아래로 내려오는 대각선
            ni = i+1*k
            nj = j+1*k
            a += matrix[ni][nj]
        s_diagonal.append(a)
 
        x, y = 0, 99
        b = matrix[x][y]
        # for dx, dy in [1, -1]:
        for kk in range(1, 100): # 왼쪽 아래로 내려오는 대각선
            nx = x+1*kk
            ny = y+(-1)*kk
            b += matrix[nx][ny]
        s_diagonal.append(b)
        return max(s_diagonal)
 
    max_v = max(row_sum(matrix), col_sum(matrix), diagonal(matrix))
    print(f'#{num_testcase} {max_v}')




## 색칠하기
T = int(input())
# 여러개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
for test_case in range(1, T + 1):
    N = int(input())
    index_matrix = [list(map(int, input().split())) for _ in range(N)]
    matrix = [[0] * 10 for _ in range(10)]
    
    for k in range(N):
        for i in range(index_matrix[k][0], index_matrix[k][2]+1):
            for j in range(index_matrix[k][1], index_matrix[k][3]+1):
                matrix[i][j] += index_matrix[k][4]
            
    num = 0
    for i in range(10):
        for k in range(10):
            if matrix[i][k] == 3:
                num += 1

    print(f'#{test_case} {num}')
```

## 만들 수 없는 최솟값 금액
``` python 
N = int(input())
money = list(map(int, input().split()))

# N = 5
# money = [3, 2, 1, 1, 9]
# 출력예시: 8

money.sort() # 동전을 작은 것부터 보겠다는 뜻. 작은금액부터 못 만들면 그게 최소 금액
target = 1 # 못 만드는 최소 금액은 1원

for data in money: # 작은 것부터 하나씩 확인
    if data > target: # 제일 작은 동전조차 result 보다 큼 -> result는 절대 못 만듦
        break
    else:
        target += data # 이 동전을 쓰면 만들 수 있는 범위가 그만큼 늘어난다.

print(target)
```

## 볼링공 고르기
``` python 
N, M = map(int, input().split())
arr = list(map(int, input().split()))

# N, M = 8, 5
# arr = [1, 5, 4, 3, 2, 4, 5, 2]

count = 0
for i in range(0, N-1):
    for k in range(i+1, N):
        if arr[i] != arr[k]:
            count += 1

print(count)
```

## 무지의 먹방 라이브
- 음식을 한 바퀴씩 깎는 게 아니라 가장 적게 남은 음식까지 한꺼번에 깎음
- 시간이 적게 걸리는 음식부터 제거해 나가는 방식
- 우선순위 큐를 이용해서 구현
``` python
import heapq

def solution(food_times, k):
    # 다 먹는 시간이 k 이하면 -1
    if sum(food_times) <= k:
        return -1
    
    # 시간이 작은 음식부터 빼야 하므로 우선순위 큐 이용
    q = []
    for i in range(len(food_times)):
        # (음식 시간, 음식 번호) 형태로 우선순위 큐에 삽입
        heapq.heappush(q, (food_times[i], i+1))

    sum_value = 0 # 먹기 위해 사용한 시간
    previous = 0 # 직전에 다 먹은 음식 시간
    length = len(food_times) # 남은 음식의 개수

    # sum_value + (현재의 음식 시간 - 이전 음식 시간) * 현재 음식 개수와 k 비교
    while sum_value + ((q[0][0] - previous) * length) <= k:
        now = heapq.heappop(q)[0]
        sum_value += (now - previous) * length
        length -= 1 # 다 먹은 음식 제외
        previous = now # 이전 음식 시간 재설정

    # 남은 음식 중에서 몇 번째 음식인지 확인하여 출력
    result = sorted(q, key = lambda x: x[1]) # 음식의 번호 기준으로 정렬
    return result[(k - sum_value) % length][1]
```
- gpt 코드
``` python
def solution(food_times, k):
    # 다 먹는 시간이 k 이하면 -1
    if sum(food_times) <= k:
        return -1

    # (남은시간, 음식번호)로 정렬
    foods = sorted((t, i+1) for i, t in enumerate(food_times))

    n = len(foods)
    prev = 0      # 이전에 제거한 층 높이
    idx = 0       # foods에서 현재 위치

    while idx < n:
        cur = foods[idx][0]                 # 현재 최소 시간
        diff = cur - prev                   # 이번에 깎을 높이
        remain = n - idx                    # 남은 음식 개수

        spend = diff * remain               # diff만큼 전부 깎는 데 걸리는 시간
        if spend <= k:
            k -= spend
            prev = cur
            # 시간이 cur인 음식들은 다 제거(0이 됨)
            while idx < n and foods[idx][0] == cur:
                idx += 1
        else:
            # 더는 층 전체 제거 불가 → 남은 음식들 중에서 k번째를 찾기
            rest = sorted(foods[idx:], key=lambda x: x[1])  # 번호순
            return rest[k % remain][1]

    return -1
```

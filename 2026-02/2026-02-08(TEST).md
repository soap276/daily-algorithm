## 거품정렬 vs 선택정렬
- 거품 정렬: 서로 인접한 두 원소를 비교하며 큰 값을 뒤로 밀어내는 방식의 정렬 알고리즘
- 선택정렬: 가장 작은 값을 선택하여 맨 앞 위치와 교환하는 방식의 정렬 알고리즘
### 두 정렬의 핵심 차이

| 구분 | 거품 정렬 | 선택 정렬 |
|------|-----------|-----------|
| 비교 방식 | 인접 원소 비교 | 전체 중 최소 선택 |
| 한 번 순회 결과 | 가장 큰 값이 뒤로 이동 | 가장 작은 값이 앞으로 이동 |
| 교환 횟수 | 많음 | 적음 |
| 이미 정렬된 경우 | 빠를 수 있음 | 여전히 느림 |
| 시간복잡도 | O(N²) | O(N²) |
| 안정성 | 안정 정렬 | 불안정 정렬 |

## 델타 문제
``` python 
# NxN 2차 배열에 숫자를 랜덤으로 저장
# 각 요소에 대해 그 요소와 이웃한 요소와의 차의 절대값 구하기
# 각 요소에 대해서 모두 조사하여 총합 구하기
N = int(input())
matrix = [list(map(int, input().split())) for _ in range(N)]

total = 0 # 전체 이웃 차이의 합을 저장할 변수
for i in range(N):
    for j in range(N):
        # 상, 하, 좌, 우 네 방향을 의미하는 델타값
        for di, dj in [[1, 0], [-1, 0], [0, 1], [0, -1]]:
            ni, nj = i+di, j+dj

            # 배열 범위를 벗어나지 않는 경우만 처리
            if 0<= ni<N and 0<=nj<N:
                # 현재 칸과 이웃 칸의 차이의 절대값을 total에 누적
                total += abs(matrix[i][j] - matrix[ni][nj])

print(total)

# # 2차원 배열의 값만 출력하는 방식
# for row in result:
#     print(*row)
```
## 부분수열 판별 문제
``` python
T = int(input())
for test_case in range(1, T+1):
    N, M = map(int, input().split())
    A = list(map(int, input().split()))
    B = list(map(int, input().split()))

    answer = 'NO' 
    j = 0 # B 인덱스의 값
    # A의 인덱스 i는 아무제한 없이 1씩 증가하니 for 문 사용
    for i in range(N): 
        if A[i] == B[j]:
            j +=1 # A의 인덱스 i는 for문이 자동으로 증가시킨다. -> j만 1 증가시켜주면 됨
        
        if j == M: # A안에서 B의 원소를 모두 발견했다 => 부분수열
            answer = 'YES'
            break

    print(f'#{test_case} {answer}')
```

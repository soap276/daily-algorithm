# List
## 배열 원소 중 최댓값이 여러개인 경우 마지막 인덱스 찾기
``` python
max_idx = 0 # 첫 원소를 최대로 가정
for i in range(1, N):
    if arr[max_idx] <= arr[i]: # 더 큰값 또는 같은값이면
        max_idx = i # max_idx 갱신
```

## 찾는 값이 배열에 있으면 해당 원소의 인덱스, 없으면 -1을 idx에 넣기
``` python 
idx = -1 # 찾는 값이 없다고 가정
for i in range(N):
    if arr[i] == V: # arr[i]가 찾는 값이면
        idx = i # 인덱스 저장
        break # for i
```

## 버블 정렬
- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- 시간복잡도 O(n^2)
``` python
def bubble_sort(a, N): # 정렬할 List, N 원소 수
    for i in range(N-1, 0, -1): # 범위의 끝 위치
        for j in range(i): # 비교할 왼쪽 원소 인덱스 j
            if a[j] > a[j+1]:
                a[j], a[j+1] = a[j+1], a[j]
```

## 카운팅 정렬
- 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 선형시간에 정렬하는 효율적인 방식, k가 비교적 작을 때만 가능
- 시간복잡도 O(n+k): n은 리스트 길이, k는 정수의 최댓값
``` python
def counting_sort(DATA, TEMP, k):
    # DATA [] -- 입력 배열(원소는 0 이상 k 이하 정수)
    # TEMP [] -- 정렬된 배열
    # COUNTS [] -- 카운트 배열

    COUNTS = [0] * (k+1)

    for i in range(len(DATA)): # DATA[i] 발생횟수 기록
        COUNTS[DATA[i]] += 1

    for i in range(1, k+1): # COUNTS 값 조정 (누적)
        COUNTS[i] += COUNTS[i-1]

    for i in range(len(DATA)-1, -1, -1): # 3단계
        COUNTS[DATA[i]] -= 1
        TEMP[COUNTS[DATA[i]]] = DATA[i]
```
## 완전 검색
- 모든 경우의 수를 나열해보고 확인하는 기법
- 단순하게 순열을 생성하는 방법 (baby-gin)
``` python
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3 != i1 and i3 != i2:
                    print(i1, i2, i3)
```
- 탐욕 알고리즘을 활용한 baby-gin 접근
``` python
num = 456789 # baby gin 확인할 6자리 수
c = [0] * 12 # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트

for i in range(6):
    c[num % 10] += 1
    num //= 10

i = 0
tri = run = 0

while i < 10:
    if c[i] >= 3: # triplete 조사 후 데이터 삭제
        c[i] -= 3
        tri += 1
        continue
    if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1 : # run 조사 후 데이터 삭제
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue
    i += 1

if run+tri == 2: print("Baby Gin")
else: print("Lose")
```

## 지그재그 순회
``` python
# i 행의 좌표
# j 열의 좌표
for i in range(n):
    for j in range(m):
        f(array[i][j + (m-1-2*j) * (i%2)])
```

## 델타를 활용한 2차원 배열 탐색
- 인덱스 (i, j)인 칸의 상하좌우 간 (ni, nj)
- 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
``` python
for i in range(N): # NxN 배열
    for j in range(N):
        for di, dj in [[0, 1], [1, 0], [0, -1], [-1, 0]]:
            ni, nj = i+di, j+dj
```
- 상하좌우 k칸의 합계 중 최댓값 (k=2)
``` python
max_v = 0
for i in range(N): # NxN 배열
    for j in range(N):
        s = arr[i][j]
        for di, dj in [[0, 1], [1, 0], [0, -1], [-1, 0]]: # 각 방향
            for c in range(1, k+1): # 거리별
                ni, nj = i+di*c, j+dj*c
                if 0<=ni<N and 0<=nj<N:
                    s+= arr[ni][nj]
        if max_v < s:
            max_v = s
```
## 전치 행렬
``` python
# i: 행의 크기 len(arr), j: 열의 크기 len(arr[0])
arr = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # 3*3 행렬

for i in range(3):
    for j in range(3):
        if i < j:
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```
## 대각선에 해당하는 원소들
``` python
for i in range(N):
    f(arr[i][i]) # 오른쪽 아래 방향

for i in range(N):
    f(arr[i][N-1-i]) # 오른쪽 위 방향

# 대각선 원소의 합 구하기 -> 오른쪽 아래, 오른쪽 위 방향으로 더하기를 수행한 뒤 중앙값 하나 뺌 (중앙값 하나 겹치니까)
```
## 부분집합
- 비트 연산으로 부분집합을 생성하는 방법
``` python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)

for i in range(1<<n): # 2의 N승 -> 부분집합의 개수, <<: 1을 왼쪽으로 j칸 이동시키는 것
    subset = [] 
    for j in range(n): # 원소의 수만큼 비트를 비교함
        if i & (1<<j): # i의 j번 비트가 1인 경우
            subset.append(arr[j])
            print(arr[j], end=', ') # j번 원소 출력
    print()
print()
```
``` python
arr = list(map(int, input().split()))
n = len(arr)
answer = 'NO'
for i in range(1, 1<<n): # 1부터 인 것 = 공집합을 제외한다. 
    s = 0 # 부분집합의 합
    for j in range(n):
        if i & (1<<j):
            s += arr[j] 
    if s == 0:
        answer = 'YES'
        break
print(answer)
```
``` python
# 각 원소가 부분집합에 포함되었는지를 loop를 이용하여 확인하고 부분집합을 생성하는 방법
def print_subset(bit):
    A = [1, 2, 3, 4]
    for i in range(4):
        if bit[i] == 1:
            print(A[i], end=' ')
    print()

bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
                print_subset(bit)
```
## 순차 검색
- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
- 정렬되어 있지 않은 경우 -> 첫번째 원소부터 순서대로 검색대상과 키 값이 같은 원소가 있는지 비교. 시간복잡도 O(n)
- 찾고자 하는 원소의 순서에 따라 비교 횟수 결정. 검색 실패 시 마지막 원소까지 비교하므로 평균 비교 횟수 n
``` python
# 정렬되어 있지 않은 경우
key = 2
def find_key(arr, n, key):
    for i in range(n):
        if arr[i] == key:
            return i # 인덱스 반환
    return -1

def sequential_search(a, n, key):
    i = 0
    while i < n and a[i] != key: # 무조건 범위 먼저, 두 조건의 위치를 바꾸면 결과 이상
        i += 1
    if i < n:
        return i
    else:
        return -1
```

- 순차 검색 - 정렬되어 있는 경우 -> 오름차순 정렬. 검색 실패를 반환하는 경우에도 평균 비교 횟수가 반으로 줄어듬 (n+1)/2
``` python
def sequential_search2(a, n, key):
    for i in range(n):
        if a[i] == key:
            return i
        elif a[i]> key:
            return -1
    return -1

def sequential_search2(a, n, key):
    i = 0
    while i < n and a[i] < key:
        i+=1
    if i < n and a[i] == key:
        return i
    else:
        return -1
```

## 이진 검색
- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색 위치를 결정, 자료는 정렬된 상태여야 함
- 자료에 삽입이나 삭제가 발생했을 때 상태를 항상 정렬 상태로 유지하는 추가 작업 필요
``` python
def binary_search(a, N, key): # key를 찾으면 인덱스, 실패하면 -1 반환
    start = 0
    end = N-1
    while start <= end :
        middle = (start + end) // 2
        if a[middle] == key: # 검색 성공
            return middle
        elif a[middle] > key: # 찾는 값보다 크면
            end = middle - 1 # 왼쪽 구간 선택
        else:
            start = middle + 1 # 오른쪽 구간 선택

    return -1 # 검색 실패
```

## 선택 정렬 (vs 버블정렬)
- 주어진 리스트에서 최솟값(최솟값의 위치)을 찾고 리스트의 맨 앞에 위치한 값과 교환
- 시간복잡도 O(n^2)
``` python
def selection_sort(a, N):
    for i in range(N-1): # 정렬 구간의 시작 인덱스
        min_idx = i # 첫 원소를 최솟값으로 가정
        for j in range(i+1, N):
            if a[min_idx] > a[j]: # 최솟값의 인덱스 갱신
                min_idx = j
        a[i], a[min_idx] = a[min_idx], a[i] # 구간 최솟값을 구간 맨 앞으로
```
## 셀렉션 알고리즘
- 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
- 시간복잡도 O(kn)
``` python
def select(arr, k):
    for i in range(0, k):
        min_index = i
        for j in range(i+1, len(arr)):
            if arr[min_index] > arr[j]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr[k-1]
```

# String
- 파이썬에서의 문자열
- 시퀀스 자료형으로 분류: replace(), split(), isalpha(), find() 메소드 사용가능
- 요소 값은 변경 불가 s[1] = 'a'로 변경 X
``` python
c = 'A'
# 컴퓨터에서 문자열을 해당되는 숫자코드로 바꾸는 법
print(ord(c)) # 65 출력
# 숫자코드를 문자로 바꿈
print(chr(65))
```
## 문자열 뒤집기
```python
# 문자열을 역순으로 재정의
s = 'reverse'
s = s[::-1]
```
``` python
# 리스트로 변환 후 다시 문자열로 변환
s = 'abcd'
s = list(s)
s.reverse()
s = ''.join(s)
```
```python
s = 'Reverse this strings'
# 뒤집은 새로운 문자열 s2
s2 = ''
N = len(s)

# 원본 문자열의 마지막 인덱스부터 차례대로 작성
for i in range(N-1, -1, -1):
    s2 += s[i]

print(s2)
print(s[::-1])
```

## 문자열 비교
- ==: 값이 같은지 비교
- is: 같은 객체(메모리 주소)인지 비교

## 회문
- 기러기, 토마토, 스위스와 같이 똑바로 읽어도 거꾸로 읽어도 똑같은 문장이나 낱말
- 문자열 길이의 반만 비교하면 됨



## 패턴 매칭
- 고지식한 알고리즘: 완전탐색
- 본문 문자열을 처음부터 끝까지 차례대로 순회하며 패턴 내의 문자들을 일일이 비교하는 방식
``` python
# 3_string/pattern
def brute_force(p, t): # p 찾을 패턴, t 본문 문자열, 패턴이 있으면 인덱스, 없으면 -1 리턴
    i = 0 # t의 인덱스 
    j = 0 # p의 인덱스
    M = len(p)
    N = len(t)
    while j < M and i < N:
        if t[i] != p[j]: # 다른 글자인 경우
            i = i - j
            j = -1
        i += 1
        j += 1
    if j == M:
        return i - M # 검색 성공
    else:
        return -1 # 검색 실패
```

## KPM 알고리즘
- 패턴의 각 위치에서 매칭에 실패했을 때 돌아갈 위치를 미리 계산
- 불일치가 발생했을 경우 이동할 다음 위치를 계산하는 전처리 필요

- 보이어 무어 알고리즘: 패턴 오른쪽 쯕에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우 이동 거리는 패턴의 길이만큼 됨
- 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재할 경우 오른쪽에서 일치한 부분을 고려해 점프

``` python
t = 'TTTTTTTATTAATA'
p = 'TTA'

print(brute_force(p, t))


    s = input()

    # s 문자열이 회문인가?
    # 전체를 뒤집어서 원본과 같은지
    # 절반 기준으로 앞과 뒤가 같은지 비교

    N = len(s)
    
    # 문제에서 원하는 답
    answer = 0 # 회문이 아니다 라고 가정
    
    for i in range(N//2):
        # 앞쪽 i번 글자와 뒤쪽 N-1-i번 글자를 비교
        # 같으면 다음 글자비교 이어서..
        # 다르면 회문이 아니니까 비교 중단
        if s[i] != s[N-1-i]:
            # 남은 글자는 볼 필요 없으니 반복 중단
            break 
    else:
        # 위의 반복분이 중간에 종료되지 않았다면 실행되는 코드
        # 비교를 하다가 앞과 뒤가 다른 적이 없었다 라는 말이니까 회문 발견
        answer = 1
    print(f'#{test_case} {answer}')
```

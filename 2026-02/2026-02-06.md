## 문자열 뒤집기
# 문자열을 역순으로 재정의
s = 'reverse'
s = s[::-1]


s = 'Reverse this strings'

# 뒤집은 새로운 문자열 s2
s2 = ''
N = len(s)

# 원본 문자열의 마지막 인덱스부터 차례대로 작성
for i in range(N-1, -1, -1):
    s2 += s[i]

print(s2)
print(s[::-1])



# 리스트로 변환 후 다시 문자열로 변환
s = 'abcd'
s = list(s)
s.reverse()
s = ''.join(s)

- 문자열 비교
- ==: 값이 같은지 비교
- is: 같은 객체(메모리 주소)인지 비교

# 회문
- 기러기, 토마토, 스위스와 같이 똑바로 읽어도 거꾸로 읽어도 똑같은 문장이나 낱말
- 문자열 길이의 반만 비교하면 됨



## 패턴 매칭

# 고지식한 알고리즘
- 완전탐색

# 3_string/pattern
def brute_force(p, t): # p 찾을 패턴, t 본문 문자열, 패턴이 있으면 인덱스, 없으면 -1 리턴
    i = 0 # t의 인덱스 
    j = 0 # p의 인덱스
    M = len(p)
    N = len(t)
    while j < M and i < N:
        if t[i] != [j]: # 다른 글자인 경우
            i = i - j
            j = -1
        i += 1
        j += 1
    if j == M:
        return i - M # 검색 성공
    else:
        return -1 # 검색 실패
    

t = 'TTTTTTTATTAATA'
p = 'TTA'

print(brute_force(p, t))


    s = input()

    # s 문자열이 회문인가?
    # 전체를 뒤집어서 원본과 같은지
    # 절반 기준으로 앞과 뒤가 같은지 비교

    N = len(s)
    
    # 문제에서 원하는 답
    answer = 0 # 회문이 아니다 라고 가정
    
    for i in range(N//2):
        # 앞쪽 i번 글자와 뒤쪽 N-1-i번 글자를 비교
        # 같으면 다음 글자비교 이어서..
        # 다르면 회문이 아니니까 비교 중단
        if s[i] != s[N-1-i]:
            # 남은 글자는 볼 필요 없으니 반복 중단
            break 
    else:
        # 위의 반복분이 중간에 종료되지 않았다면 실행되는 코드
        # 비교를 하다가 앞과 뒤가 다른 적이 없었다 라는 말이니까 회문 발견
        answer = 1
    print(f'#{test_case} {answer}')

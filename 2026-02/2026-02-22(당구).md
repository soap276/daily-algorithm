## ìµœì¢… ì½”ë“œ
``` python

import socket
import time
import math

# ë‹‰ë„¤ì„ì„ ì‚¬ìš©ìì— ë§ê²Œ ë³€ê²½í•´ ì£¼ì„¸ìš”.
NICKNAME = ''

# ì¼íƒ€ì‹¸í”¼ í”„ë¡œê·¸ë¨ì„ ë¡œì»¬ì—ì„œ ì‹¤í–‰í•  ê²½ìš° ë³€ê²½í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
HOST = '127.0.0.1'

# ì¼íƒ€ì‹¸í”¼ í”„ë¡œê·¸ë¨ê³¼ í†µì‹ í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ì½”ë“œê°’ìœ¼ë¡œ ë³€ê²½í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
PORT = 1447
CODE_SEND = 9901
CODE_REQUEST = 9902
SIGNAL_ORDER = 9908
SIGNAL_CLOSE = 9909

# ê²Œì„ í™˜ê²½ì— ëŒ€í•œ ìƒìˆ˜ì…ë‹ˆë‹¤.
TABLE_WIDTH = 254
TABLE_HEIGHT = 127
NUMBER_OF_BALLS = 6
HOLES = [[0, 0], [127, 0], [254, 0], [0, 127], [127, 127], [254, 127]]

order = 0
balls = [[0, 0] for i in range(NUMBER_OF_BALLS)]

sock = socket.socket()
print('Trying to Connect: %s:%d' % (HOST, PORT))
sock.connect((HOST, PORT))
print('Connected: %s:%d' % (HOST, PORT))

send_data = '%d/%s' % (CODE_SEND, NICKNAME)
sock.send(send_data.encode('utf-8'))
print('Ready to play!\n--------------------')

while True:

    # Receive Data
    recv_data = (sock.recv(1024)).decode()
    print('Data Received: %s' % recv_data)

    # Read Game Data
    split_data = recv_data.split('/')
    idx = 0
    try:
        for i in range(NUMBER_OF_BALLS):
            for j in range(2):
                balls[i][j] = float(split_data[idx])
                idx += 1
    except:
        send_data = '%d/%s' % (CODE_REQUEST, NICKNAME)
        print("Received Data has been currupted, Resend Requested.")
        continue

    # Check Signal for Player Order or Close Connection
    if balls[0][0] == SIGNAL_ORDER:
        order = int(balls[0][1])
        print('\n* You will be the %s player. *\n' % ('first' if order == 1 else 'second'))
        continue
    elif balls[0][0] == SIGNAL_CLOSE:
        break

    # Show Balls' Position
    print('====== Arrays ======')
    for i in range(NUMBER_OF_BALLS):
        print('Ball %d: %f, %f' % (i, balls[i][0], balls[i][1]))
    print('====================')

    angle = 0.0
    power = 0.0

    ##############################
    # ì—¬ê¸°ì„œë¶€í„° ì½”ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”.
    ##############################

    # ì¹  ê³µ ì¸ë±ìŠ¤ ì„ íƒ(ë„ˆê°€ ì“°ë˜ ë°©ì‹ ìœ ì§€)
    ix = order
    if balls[ix][0] == -1.0 and balls[ix][1] == -1.0:
        ix += 2
        if balls[ix][0] == -1.0 and balls[ix][1] == -1.0:
            ix += 2
            if ix >= 5:
                ix = 5

    # í° ê³µ / íƒ€ê²Ÿ ê³µ ì¢Œí‘œ
    white = [balls[0][0], balls[0][1]]
    target = [balls[ix][0], balls[ix][1]]

    # âœ… (ìµœì†Œ ìˆ˜ì • 1) íƒ€ê²Ÿì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ í™€ ì„ íƒ
    hole = min(HOLES, key=lambda h: math.hypot(target[0] - h[0], target[1] - h[1]))

    # ê³ ìŠ¤íŠ¸ë³¼(ì ‘ì ) ê¸°ë°˜ ìŠ¤íŠ¸ë ˆì´íŠ¸ ìƒ·
    BALL_DIAMETER = 5.73  # âœ… (ìµœì†Œ ìˆ˜ì • 2) ê³µ ì§€ë¦„

    d = math.hypot(hole[0] - target[0], hole[1] - target[1])
    if d == 0:
        ghost = target[:]
    else:
        ux = (hole[0] - target[0]) / d
        uy = (hole[1] - target[1]) / d
        ghost = [target[0] - ux * BALL_DIAMETER, target[1] - uy * BALL_DIAMETER]

    deg = math.degrees(math.atan2(ghost[1] - white[1], ghost[0] - white[0]))
    angle = (90 - deg) % 360

    dist_wg = math.hypot(ghost[0] - white[0], ghost[1] - white[1])
    power = max(30, min(100, (dist_wg + d) * 0.35))

    # ì£¼ì–´ì§„ ë°ì´í„°(ê³µì˜ ì¢Œí‘œ)ë¥¼ í™œìš©í•˜ì—¬ ë‘ ê°œì˜ ê°’ì„ ìµœì¢… ê²°ì •í•˜ê³  ë‚˜ë©´,
    # ë‚˜ë¨¸ì§€ ì½”ë“œì—ì„œ ì¼íƒ€ì‹¸í”¼ë¡œ ê°’ì„ ë³´ë‚´ ìë™ìœ¼ë¡œ í”Œë ˆì´ë¥¼ ì§„í–‰í•˜ê²Œ í•©ë‹ˆë‹¤.
    #   - angle: í° ê³µì„ ë•Œë ¤ì„œ ë³´ë‚¼ ë°©í–¥(ê°ë„)
    #   - power: í° ê³µì„ ë•Œë¦´ í˜ì˜ ì„¸ê¸°
    # 
    # ì´ ë•Œ ì£¼ì˜í•  ì ì€ powerëŠ” 100ì„ ì´ˆê³¼í•  ìˆ˜ ì—†ìœ¼ë©°,
    # power = 0ì¸ ê²½ìš° í˜ì´ ì œë¡œ(0)ì´ë¯€ë¡œ ì•„ë¬´ëŸ° ë°˜ì‘ì´ ë‚˜íƒ€ë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
    #
    # ì•„ë˜ëŠ” ì¼íƒ€ì‹¸í”¼ì™€ í†µì‹ í•˜ëŠ” ë‚˜ë¨¸ì§€ ë¶€ë¶„ì´ë¯€ë¡œ ìˆ˜ì •í•˜ë©´ ì•ˆë©ë‹ˆë‹¤.
    ##############################

    merged_data = '%f/%f/' % (angle, power)
    sock.send(merged_data.encode('utf-8'))
    print('Data Sent: %s' % merged_data)

sock.close()
print('Connection Closed.\n--------------------')
```


``` python
import math

# ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚°
def calcul_distance(x, y):
    dx = y[0] - x[0]
    dy = y[1] - x[1]
    return math.sqrt(dx**2 + dy**2)

# ë‘ ì  ì‚¬ì´ì˜ ê°ë„ ê³„ì‚°
def calcul_angel(x, y):
    # math.atan2 í•¨ìˆ˜ëŠ” ë‘ ì  ì‚¬ì´ì˜ yì¢Œí‘œ ì°¨ì´ì™€ xì¢Œí‘œ ì°¨ì´ë¥¼ ì´ìš©í•˜ì—¬
    # ê°ë„ë¥¼ ë¼ë””ì•ˆ ë‹¨ìœ„ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤. (y[1] - x[1]): yì¢Œí‘œ ì°¨ì´, (y[0] - x[0]): xì¢Œí‘œ ì°¨ì´
    return math.atan2(y[1]-x[1], y[0]-x[0])

# ëª©í‘œêµ¬ì—ì„œ ê° í™€ê¹Œì§€ì˜ ê°ë„ ê³„ì‚°
def calcul_dis_angs(target, holes):
    # ëª©í‘œêµ¬ì—ì„œ ê° í™€ê¹Œì§€ì˜ ê±°ë¦¬ ê³„ì‚°
    dis_to_holes = [calcul_distance(target, hole) for hole in holes]
    # ëª©í‘œêµ¬ì—ì„œ ê° í™€ê¹Œì§€ì˜ ê°ë„ ê³„ì‚°
    angels_to_holes = [calcul_angel(target, hole) for hole in holes]
    return dis_to_holes, angels_to_holes

# ê°€ì¥ ê°€ê¹Œìš´ í™€ì„ ì°¾ëŠ” í•¨ìˆ˜
def best_hole(dis_to_holes, angels_to_holes):
    # ê°€ì¥ ì§§ì€ ê±°ë¦¬ì˜ í™€ì˜ ì¸ë±ìŠ¤
    best_hole_idx = dis_to_holes.index(min(dis_to_holes))
    # ê°€ì¥ ê°€ê¹Œìš´ í™€ì˜ ì¸ë±ìŠ¤ì™€ ê°ë„ ë°˜í™˜
    return best_hole_idx, angels_to_holes[best_hole_idx]

# ë‚´ ê³µì˜ ìœ„ì¹˜(ì„ì˜ì˜ ìœ„ì¹˜ë¡œ ì„¤ì •ë¨)
myball = [127, 63.5]
# ëª©í‘œêµ¬ì˜ ìœ„ì¹˜(ì„ì˜ì˜ ìœ„ì¹˜ë¡œ ì„¤ì •ë¨)
target = [150, 90]
# myball = balls[0]
# target = balls[target_idx]  # ì„ /í›„ê³µ ê·œì¹™ì— ë§ì¶° ì„ íƒ


# í™€ì˜ ìœ„ì¹˜ (ì „ì²´ í…Œì´ë¸”ìƒì˜ ìœ„ì¹˜ë¥¼ ì•½ê°„ ì´ë™ì‹œì¼œ ì¡°ì •í•¨)
# holes = [[0 , 0], [127, 0], [254, 0], [0, 127], [127, 127], [254, 127]]
# í™€ ì¡ì•„ë‹¹ê¸°ê¸°
r = 5.73 # ê³µì˜ ì§ê²©
rr = 5.73 / 2
const = 0.3 # ìƒìˆ˜ ê°’
k = r * const # ê³µì˜ í¬ê¸°ì™€ ìƒìˆ˜ë¥¼ ê³±í•˜ì—¬ ì˜¤í”„ì…‹ì„ ê³„ì‚°
holes = [[0+k , 0+k],  # ì™¼ìª½ ì•„ë˜ í™€
         [127, 0+k/2], # ê°€ìš´ë° ì•„ë˜ í™€
         [254-k, 0+k], # ì˜¤ë¥¸ìª½ ì•„ë˜ í™€
         [0+k, 127-k], # ì™¼ìª½ ìœ„ í™€
         [127, 127-k/2], # ê°€ìš´ë° ìœ„ í™€
         [254-k, 127-k]  # ì˜¤ë¥¸ìª½ ìœ„ í™€
         ]

# ëª©í‘œêµ¬ì—ì„œ ê° í™€ê¹Œì§€ì˜ ê±°ë¦¬ì™€ ê°ë„ ê³„ì‚°
dis_to_holes, angels_to_holes = calcul_dis_angs(target, holes)

# ê°€ì¥ ê°€ê¹Œìš´ í™€ì„ ì„ íƒ (ê°€ì¥ ì§§ì€ ê±°ë¦¬ë¥¼ ê°€ì§€ëŠ” í™€)
best_idx, ang_th = best_hole(dis_to_holes, angels_to_holes)


# âœ… ê³ ìŠ¤íŠ¸ë³¼(ì ‘ì ) = ëª©í‘œêµ¬ì—ì„œ "í™€ ë°˜ëŒ€ë°©í–¥ìœ¼ë¡œ ì§ê²½(=2R)" ì´ë™
d = dis_to_holes[best_idx]
if d == 0:
    ghost = target[:]  # ì˜ˆì™¸
else:
    ux = (holes[best_idx][0] - target[0]) / d
    uy = (holes[best_idx][1] - target[1]) / d
    ghost = [
        target[0] - ux * r,
        target[1] - uy * r
    ]

# ë‚´ ê³µ -> ê³ ìŠ¤íŠ¸ë³¼ ê°ë„(ë¼ë””ì•ˆ)
ang_wg = calcul_angel(myball, ghost)

# ì¼íƒ€ì‹¸í”¼ ê°ë„(0ë„=ìœ„, 90ë„=ì˜¤ë¥¸ìª½)ë¡œ ë³€í™˜
deg = math.degrees(ang_wg)   # ìˆ˜í•™: 0ë„=ì˜¤ë¥¸ìª½
# angle = 90 - deg
angle = (90 - deg) % 360
if angle < 0:
    angle += 360

# power
dist_wg = calcul_distance(myball, ghost)
power = max(25, min(100, (dist_wg + d) * 0.35))

# # ê³µì˜ ë°˜ì§€ë¦„ì„ ê³ ë ¤í•´ ëª©í‘œêµ¬ì˜ ì ‘ì ê¹Œì§€ì˜ ê°ë„ë¥¼ ê³„ì‚°
# # offsetì€ ëª©í‘œêµ¬ì™€ í™€ ì‚¬ì´ì˜ ê°ë„ì— ì¶”ê°€ë  ê°ë„
# offset = math.atan2(r/2, dis_to_holes[best_hole_idx])

# # ëª©í‘œêµ¬ì™€ í™€ ì‚¬ì´ì˜ ê°ë„ì— ì˜¤í”„ì…‹ì„ ì¶”ê°€í•˜ì—¬ ìµœì¢… ëª©í‘œ ê°ë„ë¥¼ ê³„ì‚°
# target_angel = best_hole_angle + offset

# # ë‚´ ê³µì„ ë§ì¶œ ì ‘ì ì˜ ìœ„ì¹˜
# final_pos =[
#     target[0] - math.cos(target_angel) * (r/2),
#     target[1] - math.cos(target_angel) * (r/2)
# ]
# # ë‚´ ê³µê³¼ ëª©í‘œêµ¬ì˜ ì ‘ì  ì‚¬ì´ì˜ ê°ë„ë¥¼ ê³„ì‚°
# final_angel = math.degrees(calcul_angel(myball, final_pos))
# # íƒ€ê²©ë ¥ (ì„ì˜ë¡œ ì„¤ì •ëœ ê°’)
# power = 100
```

``` python
import math

# ê¸°ë³¸ì •ë³´ =======================================
gamma.order # 1ì´ë©´ ë‚´ ì°¨ë¡€, 0ì´ë©´ ìƒëŒ€ ì°¨ë¡€
Ball_r = 5.73/2 # ê³µì˜ ë°˜ì§€ë¦„
W = 254
H = 127
HOLES = [[0, 0], [127, 0], [254, 0], [0, 127], [127, 127], [254, 127]] 
# í•¨ìˆ˜ ë§Œë“¤ê¸° ====================================

def shot():
    # ë‚´ ê³µê³¼ ëª©í‘œ ê³µì˜ ìœ„ì¹˜ë¥¼ gameDataì—ì„œ ë¶ˆëŸ¬ì™€ ê°ê°ì˜ ë³€ìˆ˜ì— ì €ì¥
    A = (a_1, a_2) = (gameData.balls[0][0], gameData.balls[0][1]) # ë‚´ ê³µì˜ ìœ„ì¹˜
    B = (b_1, b_2) = (gameData.balls[1][0], gameData.balls[1][1]) # ë‚´ê°€ ë§ì¶°ì•¼ í•  ëª©í‘œ ê³µì˜ ìœ„ì¹˜

    # ëª©ì ì§€(íƒ€ê²Ÿ í™€)ì„¤ì • (í•˜ë“œì½”ë”©ëœ ì¡°ê±´ë¬¸ì„ í†µí•´ ê²°ì •)
    target = None
    if (a_1 != b_1) and (a_2 != b_2): # ë‚´ ê³µê³¼ ëª©í‘œ ê³µì˜ x, y ì¢Œí‘œ ëª¨ë‘ ë‹¤ë¥¸ ê²½ìš°
        if (a_1<b_1) and (a_2<b_2):
            target = HOLES[5] # ë‚´ ê³µì´ ëª©í‘œ ê³µì˜ ì™¼ìª½ ì•„ë˜ì— ìˆì„ ê²½ìš° ì˜¤ë¥¸ìª½ ìœ„ í™€ ì„ íƒ
        elif (a_1<b_1) and (a_2>b_2):
            target = HOLES[2] # ë‚´ ê³µì´ ëª©í‘œ ê³µì˜ ì™¼ìª½ ìœ„ì— ìˆì„ ê²½ìš° ì˜¤ë¥¸ìª½ ì•„ë˜ í™€ ì„ íƒ
        elif (a_1 > b_1) and (a_2 < b_2):
            target = HOLES[1] # ë‚´ ê³µì´ ëª©í‘œ ê³µì˜ ì˜¤ë¥¸ìª½ ì•„ë˜ì— ìˆì„ ê²½ìš° ì¤‘ì•™ ì•„ë˜ í™€ ì„ íƒ
        elif (a_1 > b_1) and (a_2 > b_2):
            target = HOLES[0] # ë‚´ ê³µì´ ëª©í‘œ ê³µì˜ ì˜¤ë¥¸ìª½ ìœ„ì— ìˆì„ ê²½ìš° ì™¼ìª½ ì•„ë˜ í™€ ì„ íƒ

    elif a_1 == b_1 == 127: # ë‚´ ê³µê³¼ ëª©í‘œ ê³µì˜ xì¢Œí‘œê°€ ëª¨ë‘ ì¤‘ì•™(127)ì¸ ê²½ìš°
        if a_2 < b_2:
            target = HOLES[4] # ë‚´ ê³µì´ ëª©í‘œ ê³µì˜ ì•„ë˜ìª½ì— ìˆì„ ê²½ìš° ì¤‘ì•™ ìœ„ í™€ ì„ íƒ
        else:
            target = HOLES[3] # ë‚´ ê³µì´ ëª©í‘œ ê³µì˜ ìœ„ìª½ì— ìˆì„ ê²½ìš° ì™¼ìª½ ìœ„ í™€ ì„ íƒ

    # ğŸ‘‰ ì•ˆì „ì¥ì¹˜
    if target is None:
        target = HOLES[0]

    # ëª©í‘œ ê³µì„ ë§ì¶”ê³  ì‹¶ì€ ìœ„ì¹˜ ê³„ì‚°(ëª©í‘œ ê³µê³¼ íƒ€ê²Ÿ í™€ì˜ ë°©í–¥ìœ¼ë¡œ ê³µì˜ ë°˜ì§€ë¦„ë§Œí¼ ë–¨ì–´ì§„ ìœ„ì¹˜)
    dx, dy = target[0] - B[0], target[1] - B[1] # ëª©í‘œ ê³µê³¼ íƒ€ê²Ÿ í™€ ì‚¬ì´ì˜ x, y ì¢Œí‘œ ê³„ì‚°
    dist = math.sqrt(dx**2 + dy**2) # ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬ ê³„ì‚° (í”¼íƒ€ê³ ë¼ìŠ¤ ì •ë¦¬)
    
    if dist == 0:
        return
    
    # ëª©í‘œ ê³µì˜ ì¤‘ì‹¬ì—ì„œ íƒ€ê²Ÿ í™€ ë°©í–¥ìœ¼ë¡œ ê³µì˜ ë°˜ì§€ë¦„ ê±°ë¦¬ë§Œí¼ ì´ë™í•œ ì  (New_B) ê³„ì‚°
    New_B = (b_1 - Ball_r*dx/dist, b_2 - Ball_r*dy/dist)
    # ì§€í”¼í‹°ëŠ” 2 ê³±í•˜ë¼ê³  í•¨
    # New_B = (b_1 - 2*Ball_r*dx/dist, b_2 - 2*Ball_r*dy/dist)

    # ë‚´ ê³µ(A)ê³¼ ë‚´ê°€ ëª©í‘œë¡œ í•˜ëŠ” ìœ„ì¹˜ (New_B)ì‚¬ì´ì˜ ê°ë„ ê³„ì‚°
    angel = math.atan2(New_B[1] - A[1], New_B[0] - A[0])
    # ì•„ë˜ ì„¸ ì¤„ ì§€í”¼í‹° ì½”ë“œ
    # rad = math.atan2(New_B[1] - A[1], New_B[0] - A[0])
    # deg = math.degrees(rad)
    # angle = (90 - deg) % 360    
    
    # í˜ì€ ì„ì˜ë¡œ 100 ì„¤ì • (ì´ ë¶€ë¶„ì€ ì‹¤ì œ ê²Œì„ ìƒí™©ì—ì„œ ì¡°ì • í•„ìš”)
    power = 100

    conn.send(angel, power) # ê³„ì‚°ëœ ê°ë„ì™€ í˜ì„ ì‚¬ìš©í•˜ì—¬ ê³µì„ ì¹˜ë¼ëŠ” ëª…ë ¹ì„ ë³´ëƒ„
    return
# ê²Œì„ ìˆœì„œê°€ ë‚´ ì°¨ë¡€(ì„ ê³µ)ì¸ ê²½ìš° shot í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ê³µì„ ì¹œë‹¤. 
if gamma.order == 1:
    shot()
```

``` python
import socket
import time
import math

# ë‹‰ë„¤ì„ì„ ì‚¬ìš©ìì— ë§ê²Œ ë³€ê²½í•´ ì£¼ì„¸ìš”.
NICKNAME = 'SEOUL01_ë°•ì¤€ì•„'

# ì¼íƒ€ì‹¸í”¼ í”„ë¡œê·¸ë¨ì„ ë¡œì»¬ì—ì„œ ì‹¤í–‰í•  ê²½ìš° ë³€ê²½í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
HOST = '127.0.0.1'

# ì¼íƒ€ì‹¸í”¼ í”„ë¡œê·¸ë¨ê³¼ í†µì‹ í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ì½”ë“œê°’ìœ¼ë¡œ ë³€ê²½í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
PORT = 1447
CODE_SEND = 9901
CODE_REQUEST = 9902
SIGNAL_ORDER = 9908
SIGNAL_CLOSE = 9909


# ê²Œì„ í™˜ê²½ì— ëŒ€í•œ ìƒìˆ˜ì…ë‹ˆë‹¤.
TABLE_WIDTH = 254
TABLE_HEIGHT = 127
NUMBER_OF_BALLS = 6
HOLES = [[0, 0], [127, 0], [254, 0], [0, 127], [127, 127], [254, 127]]

order = 0
balls = [[0, 0] for i in range(NUMBER_OF_BALLS)]

sock = socket.socket()
print('Trying to Connect: %s:%d' % (HOST, PORT))
sock.connect((HOST, PORT))
print('Connected: %s:%d' % (HOST, PORT))

send_data = '%d/%s' % (CODE_SEND, NICKNAME)
sock.send(send_data.encode('utf-8'))
print('Ready to play!\n--------------------')


while True:

    # Receive Data
    recv_data = (sock.recv(1024)).decode()
    print('Data Received: %s' % recv_data)

    # Read Game Data
    split_data = recv_data.split('/')
    idx = 0
    try:
        for i in range(NUMBER_OF_BALLS):
            for j in range(2):
                balls[i][j] = float(split_data[idx])
                idx += 1
    except:
        send_data = '%d/%s' % (CODE_REQUEST, NICKNAME)
        print("Received Data has been currupted, Resend Requested.")
        continue

    # Check Signal for Player Order or Close Connection
    if balls[0][0] == SIGNAL_ORDER:
        order = int(balls[0][1])
        print('\n* You will be the %s player. *\n' % ('first' if order == 1 else 'second'))
        continue
    elif balls[0][0] == SIGNAL_CLOSE:
        break

    # Show Balls' Position
    print('====== Arrays ======')
    for i in range(NUMBER_OF_BALLS):
        print('Ball %d: %f, %f' % (i, balls[i][0], balls[i][1]))
    print('====================')

    angle = 0.0
    power = 0.0

    ##############################
    # ì´ ìœ„ëŠ” ì¼íƒ€ì‹¸í”¼ì™€ í†µì‹ í•˜ì—¬ ë°ì´í„°ë¥¼ ì£¼ê³  ë°›ê¸° ìœ„í•´ ì‘ì„±ëœ ë¶€ë¶„ì´ë¯€ë¡œ ìˆ˜ì •í•˜ë©´ ì•ˆë©ë‹ˆë‹¤.
    #
    # ëª¨ë“  ìˆ˜ì‹ ê°’ì€ ë³€ìˆ˜, ë°°ì—´ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
    #   - order: 1ì¸ ê²½ìš° ì„ ê³µ, 2ì¸ ê²½ìš° í›„ê³µì„ ì˜ë¯¸
    #   - balls[][]: ì¼íƒ€ì‹¸í”¼ ì •ë³´ë¥¼ ìˆ˜ì‹ í•´ì„œ ê° ê³µì˜ ì¢Œí‘œë¥¼ ë°°ì—´ë¡œ ì €ì¥
    #     ì˜ˆ) balls[0][0]: í° ê³µì˜ Xì¢Œí‘œ
    #         balls[0][1]: í° ê³µì˜ Yì¢Œí‘œ
    #         balls[1][0]: 1ë²ˆ ê³µì˜ Xì¢Œí‘œ
    #         balls[4][0]: 4ë²ˆ ê³µì˜ Xì¢Œí‘œ
    #         balls[5][0]: ë§ˆì§€ë§‰ ë²ˆí˜¸(8ë²ˆ) ê³µì˜ Xì¢Œí‘œ

    # ì—¬ê¸°ì„œë¶€í„° ì½”ë“œë¥¼ ì‘ì„±í•˜ì„¸ìš”.
    # ì•„ë˜ì— ìˆëŠ” ê²ƒì€ ìƒ˜í”Œë¡œ ì‘ì„±ëœ ì½”ë“œì´ë¯€ë¡œ ììœ ë¡­ê²Œ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


    def get_distance(p1, p2):
        """ë‘ ì  ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜"""
        return math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2)

    def get_angle(p1, p2):
        """ë‘ ì  ì‚¬ì´ì˜ ê°ë„(p1ì„ ê¸°ì¤€ìœ¼ë¡œ, 0~360ë„)ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜"""
        dx = p2[0] - p1[0]
        dy = p2[1] - p1[1]
        theta = math.degrees(math.atan2(dy, dx))
        # ì¢Œí‘œê³„ ë³€í™˜ (atan2: theta -> ì¼íƒ€ì‹¸í”¼: angle)
        angle = 90 - theta
        if angle < 0:
            angle += 360
        return angle

    def is_path_clear(start_pos, end_pos, all_balls, target_ball_idx):
        """ì‹œì‘ì ê³¼ ëì  ì‚¬ì´ì— ì¥ì• ë¬¼ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
        - Args
            start_pos(list): ê²½ë¡œì˜ ì‹œì‘ì 
            end_pos(list): ê²½ë¡œì˜ ëì 
            all_balls(list): ëª¨ë“  ê³µì˜ ì¢Œí‘œ
            target_ball_idx(int): ëª©ì êµ¬ì˜ ì¸ë±ìŠ¤
        - Returns
            True: ê²½ë¡œ ìƒì— ì¥ì• ë¬¼(ëª©ì êµ¬ê°€ ì•„ë‹Œ ê³µ)ì´ ìˆëŠ” ê²½ìš°
            False: ê²½ë¡œ ìƒì— ì¥ì• ë¬¼ì´ ì—†ëŠ” ê²½ìš°
        """
        dist_path = get_distance(start_pos, end_pos)
        
        for idx, obstacle_pos in enumerate(all_balls):
            # í°ê³µ(ì¸ë±ìŠ¤ 0), ëª©ì êµ¬ì™€ ë‹¹êµ¬ëŒ€ì— ì—†ëŠ” ê³µë“¤ì€ ì œì™¸í•œë‹¤.
            if idx == 0 or idx == target_ball_idx or obstacle_pos[0] == -1:
                continue

            # ì ê³¼ ì§ì„  ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ì´ìš©í•˜ì—¬ ì¥ì• ë¬¼ê³¼ ê²½ë¡œ ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ êµ¬í•œë‹¤.
            dist_obs_to_path = abs((end_pos[1] - start_pos[1]) * obstacle_pos[0]
                                   - (end_pos[0] - start_pos[0]) * obstacle_pos[1]
                                   - (end_pos[1] * start_pos[0])
                                   + (start_pos[1] * end_pos[0])
                                   ) / dist_path
            
            # ì¥ì• ë¬¼ì´ ê²½ë¡œì˜ ìœ„í—˜ ë°˜ê²½(ë‹¹êµ¬ê³µì˜ ì§€ë¦„) ì•ˆì— ìˆë‹¤ë©´,
            if dist_obs_to_path <= 2 * BALL_RADIUS:
                # ì¥ì• ë¬¼ì´ ê²½ë¡œ 'ì‚¬ì´'ì— ìœ„ì¹˜í•˜ëŠ”ì§€ ì¶”ê°€ë¡œ í™•ì¸í•œë‹¤.
                dist_obs_to_start = get_distance(obstacle_pos, start_pos)
                dist_obs_to_end = get_distance(obstacle_pos, end_pos)
                # ì¥ì• ë¬¼ê³¼ ì²˜ìŒ/ëì  ì‚¬ì´ì˜ ê±°ë¦¬ê°€ ê²½ë¡œë³´ë‹¤ ì§§ë‹¤ë©´ 'ì‚¬ì´'ì— ìˆëŠ” ê²ƒì´ë¯€ë¡œ ì¥ì• ë¬¼ë¡œ ì·¨ê¸‰í•œë‹¤.
                if dist_obs_to_start < dist_path and dist_obs_to_end < dist_path:
                    return False
        
        return True

    def find_best_shot(white_ball_pos, all_balls, target_indices):
        """í˜„ì¬ ìƒíƒœì—ì„œ ê°€ì¥ ìµœì ì˜ ìƒ·(ê°ë„, ì„¸ê¸°)ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
        - Args
            white_ball_pos(list): í° ê³µì˜ ì¢Œí‘œ
            all_balls(list): ëª¨ë“  ê³µì˜ ì¢Œí‘œ
            target_indices(list): í˜„ì¬ ë‹¹êµ¬ëŒ€ ìœ„ì— ìˆëŠ” ëª©ì êµ¬ë“¤ì˜ ì¸ë±ìŠ¤
        - Returns
            best_shot(dict): ìµœì ì˜ ìƒ·ì˜ ì ìˆ˜ì™€ ê°ë„, ì„¸ê¸°
        """
        best_shot = {'score': float('inf'), 'angle': 0, 'power': 0}

        # ëª¨ë“  ëª©ì êµ¬ì— ëŒ€í•œ ìµœì ìƒ·ì„ ê³ ë ¤í•œë‹¤.
        for target_idx in target_indices:
            target_ball_pos = all_balls[target_idx]
            
            # 6ê°œ í™€ì— ëŒ€í•œ ìµœì ìƒ·ì„ ê³ ë ¤í•œë‹¤.
            for hole_pos in HOLES:
                # 1. ë‹¨ìœ„ ë²¡í„°ë¥¼ ì´ìš©í•˜ì—¬ ê³ ìŠ¤íŠ¸ë³¼ì˜ ì¢Œí‘œ êµ¬í•˜ê¸°
                #    ê³ ìŠ¤íŠ¸ë³¼ì€ í™€-ëª©ì êµ¬ì˜ ì—°ì¥ì„ ìƒì— ìˆìœ¼ë©°, ëª©ì êµ¬ë¥¼ ë¹—ê²¨ì¹˜ê¸° ìœ„í•´ ì„¤ì •í•˜ëŠ” ê°€ìƒì˜ ê³µì´ë‹¤.
                dist_target_to_hole = get_distance(target_ball_pos, hole_pos)
                if dist_target_to_hole == 0: 
                    continue  # ZeroDivisionError ë°©ì§€

                # ë‹¨ìœ„ ë²¡í„°ì˜ ì—­í• : ëª©ì êµ¬(target) -> í™€ ë°©í–¥
                unit_vec_x = (hole_pos[0] - target_ball_pos[0]) / dist_target_to_hole
                unit_vec_y = (hole_pos[1] - target_ball_pos[1]) / dist_target_to_hole

                # ê³ ìŠ¤íŠ¸ë³¼ : ëª©ì êµ¬ì—ì„œ í™€ì˜ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ 2Rë§Œí¼ ë–¨ì–´ì§„ ì¢Œí‘œ
                ghost_ball_pos = [
                    target_ball_pos[0] - unit_vec_x * 2 * BALL_RADIUS,
                    target_ball_pos[1] - unit_vec_y * 2 * BALL_RADIUS,
                ]

                # 2. ê²½ë¡œì— ì¥ì• ë¬¼ì´ ìˆëŠ”ì§€ í™•ì¸ (í°ê³µ -> ê³ ìŠ¤íŠ¸ë³¼, ëª©ì êµ¬ -> í™€)
                #    ì¥ì• ë¬¼ì´ ìˆë‹¤ë©´ ìµœì ìƒ·ì—ì„œ ì œì™¸í•œë‹¤.
                if (
                    not is_path_clear(white_ball_pos, ghost_ball_pos, all_balls, target_idx)
                    or not is_path_clear(target_ball_pos, hole_pos, all_balls, target_idx)
                ):
                    continue
                    
                # 3. ê°ë„, ì ìˆ˜, ì„¸ê¸° êµ¬í•˜ê¸°
                #    ê²½ë¡œê°€ ì§§ì€ ê²ƒì„ ìµœì ìœ¼ë¡œ í‰ê°€í•˜ê¸° ìœ„í•´ ê²½ë¡œì˜ ê¸¸ì´ë¥¼ ì ìˆ˜ë¡œ í•œë‹¤. 
                angle = get_angle(white_ball_pos, ghost_ball_pos)
                score = get_distance(white_ball_pos, ghost_ball_pos) + dist_target_to_hole
                power = max(20, min(100, score * 0.3))

                # 4. ìµœì ìƒ· ê°±ì‹ í•˜ê¸°
                if score < best_shot['score']:
                    best_shot = {'score': score, 'angle': angle, 'power': power}
                    # print(f"í™€ì˜ ì¢Œí‘œ: {hole_pos}, ê³ ìŠ¤íŠ¸ë³¼ì˜ ì¢Œí‘œ: {ghost_ball_pos}")

        return best_shot


    # whiteBall_x, whiteBall_y: í° ê³µì˜ X, Yì¢Œí‘œë¥¼ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ ì‚¬ìš©í•œ ë³€ìˆ˜
    # whiteBall_x = balls[0][0]
    # whiteBall_y = balls[0][1]
    white_ball_pos = balls[0]

    # # targetBall_x, targetBall_y: ëª©ì êµ¬ì˜ X, Yì¢Œí‘œë¥¼ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ ì‚¬ìš©í•œ ë³€ìˆ˜
    # targetBall_x = balls[1][0]
    # targetBall_y = balls[1][1]


    # í•„ìš”í•œ ìƒìˆ˜ ì„ ì–¸
    BALL_RADIUS = 5.74 / 2
    const = 0.15
    k = BALL_RADIUS * const
    # offsetì„ ì ìš©í•œ í™€ì˜ ì¢Œí‘œ
    HOLES = [
        [0 + k, 0 + k], 
        [127, 0 + k / 2], 
        [254 - k, 0 + k], 
        [0 + k, 127 - k], 
        [127, 127 - k / 2], 
        [254 - k, 127 - k]
    ]

    # ì„ ,í›„ê³µì— ë”°ë¥¸ ëª©ì êµ¬ì˜ ì¸ë±ìŠ¤
    if order == 1:  # ì„ ê³µ
        target_ball_indices = [1, 3]
    else:  # í›„ê³µ
        target_ball_indices = [2, 4]

    # ëª©ì êµ¬ê°€ ë‹¹êµ¬ëŒ€ ìœ„ì— ìˆëŠ” ê²½ìš° active_targetsì— ì¶”ê°€
    active_targets = []
    for target_idx in target_ball_indices:
        if balls[target_idx][0] != -1:
            active_targets.append(target_idx)

    # active_targetsì´ ì—†ëŠ” ê²½ìš°, 8ë²ˆ ê³µ(5ë²ˆ ì¸ë±ìŠ¤) ì¶”ê°€
    if not active_targets and balls[5][0] != -1:
        active_targets.append(5)

    # 8ë²ˆ ê³µì¡°ì°¨ ì—†ëŠ” ê²½ìš°
    if not active_targets:
        print("ë” ì´ìƒ ì¹  ê³µì´ ì—†ìŠµë‹ˆë‹¤.")
        angle, power = 0, 0
    else:
        # ë‹¹êµ¬ëŒ€ ìœ„ì— ëª©ì êµ¬ê°€ í•˜ë‚˜ ì´ìƒ ìˆëŠ” ê²½ìš° ìµœì ì˜ ìƒ·ì„ êµ¬í•œë‹¤.
        print("íƒ€ê²Ÿì€ ", active_targets)
        shot_to_play = find_best_shot(white_ball_pos, balls, active_targets)

        # 1. ìµœì ì˜ ìƒ·ì´ ì—†ëŠ” ê²½ìš°
        #    ê°€ì¥ ê·¼ì ‘í•œ ëª©ì êµ¬ë¥¼ ì•½í•œ ì„¸ê¸°ë¡œ íƒ€ê²©í•œë‹¤.(ìˆ˜ë¹„)
        if shot_to_play['score'] == float('inf'):
            # 1-1. ê°€ì¥ ê·¼ì ‘í•œ ëª©ì êµ¬ êµ¬í•˜ê¸°
            closest_dist = float('inf')
            closest_ball_pos = None
            for target_idx in active_targets:
                # 8ë²ˆ ê³µì€ í›„ë³´ì—ì„œ ì œì™¸í•œë‹¤.
                # if target_idx == 5:
                #     continue
                dist = get_distance(white_ball_pos, balls[target_idx])
                if dist < closest_dist:
                    closest_dist = dist
                    closest_ball_pos = balls[target_idx]
            
            # 1-2. ê°ë„ì™€ ì„¸ê¸° êµ¬í•˜ê¸°
            angle = get_angle(white_ball_pos, closest_ball_pos)
            power = 30

        # 2. ìµœì ì˜ ìƒ·ì´ ìˆëŠ” ê²½ìš°
        else:
            angle = shot_to_play['angle']
            power = shot_to_play['power']

        # print(angle, power)



    # # width, height: ëª©ì êµ¬ì™€ í° ê³µì˜ Xì¢Œí‘œ ê°„ì˜ ê±°ë¦¬, Yì¢Œí‘œ ê°„ì˜ ê±°ë¦¬
    # width = abs(targetBall_x - whiteBall_x)
    # height = abs(targetBall_y - whiteBall_y)

    # # radian: widthì™€ heightë¥¼ ë‘ ë³€ìœ¼ë¡œ í•˜ëŠ” ì§ê°ì‚¼ê°í˜•ì˜ ê°ë„ë¥¼ êµ¬í•œ ê²°ê³¼
    # #   - 1radian = 180 / PI (ë„)
    # #   - 1ë„ = PI / 180 (radian)
    # # angle: ì•„í¬íƒ„ì  íŠ¸ë¡œ ì–»ì€ ê°ë„ radianì„ degreeë¡œ í™˜ì‚°í•œ ê²°ê³¼
    # radian = math.atan(width / height) if height > 0 else 0
    # angle = 180 / math.pi * radian
    
    # # ëª©ì êµ¬ê°€ í° ê³µê³¼ ìƒí•˜ì¢Œìš°ë¡œ ì¼ì§ì„ ìƒì— ìœ„ì¹˜í–ˆì„ ë•Œ ê°ë„ ì…ë ¥
    # if whiteBall_x == targetBall_x:
    #     if whiteBall_y < targetBall_y:
    #         angle = 0
    #     else:
    #         angle = 180
    # elif whiteBall_y == targetBall_y:
    #     if whiteBall_x < targetBall_x:
    #         angle = 90
    #     else:
    #         angle = 270

    # # ëª©ì êµ¬ê°€ í° ê³µì„ ì¤‘ì‹¬ìœ¼ë¡œ 3ì‚¬ë¶„ë©´ì— ìœ„ì¹˜í–ˆì„ ë•Œ ê°ë„ë¥¼ ì¬ê³„ì‚°
    # if whiteBall_x > targetBall_x and whiteBall_y > targetBall_y:
    #     radian = math.atan(width / height)
    #     angle = (180 / math.pi * radian) + 180
    
    # # ëª©ì êµ¬ê°€ í° ê³µì„ ì¤‘ì‹¬ìœ¼ë¡œ 4ì‚¬ë¶„ë©´ì— ìœ„ì¹˜í–ˆì„ ë•Œ ê°ë„ë¥¼ ì¬ê³„ì‚°
    # elif whiteBall_x < targetBall_x and whiteBall_y > targetBall_y:
    #     radian = math.atan(height / width)
    #     angle = (180 / math.pi * radian) + 90
        
    # # distance: ë‘ ì (ì¢Œí‘œ) ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ê³„ì‚°
    # distance = math.sqrt(width**2 + height**2)

    # # power: ê±°ë¦¬ distanceì— ë”°ë¥¸ í˜ì˜ ì„¸ê¸°ë¥¼ ê³„ì‚°
    # power = distance * 0.5






    # ì£¼ì–´ì§„ ë°ì´í„°(ê³µì˜ ì¢Œí‘œ)ë¥¼ í™œìš©í•˜ì—¬ ë‘ ê°œì˜ ê°’ì„ ìµœì¢… ê²°ì •í•˜ê³  ë‚˜ë©´,
    # ë‚˜ë¨¸ì§€ ì½”ë“œì—ì„œ ì¼íƒ€ì‹¸í”¼ë¡œ ê°’ì„ ë³´ë‚´ ìë™ìœ¼ë¡œ í”Œë ˆì´ë¥¼ ì§„í–‰í•˜ê²Œ í•©ë‹ˆë‹¤.
    #   - angle: í° ê³µì„ ë•Œë ¤ì„œ ë³´ë‚¼ ë°©í–¥(ê°ë„)
    #   - power: í° ê³µì„ ë•Œë¦´ í˜ì˜ ì„¸ê¸°
    # 
    # ì´ ë•Œ ì£¼ì˜í•  ì ì€ powerëŠ” 100ì„ ì´ˆê³¼í•  ìˆ˜ ì—†ìœ¼ë©°,
    # power = 0ì¸ ê²½ìš° í˜ì´ ì œë¡œ(0)ì´ë¯€ë¡œ ì•„ë¬´ëŸ° ë°˜ì‘ì´ ë‚˜íƒ€ë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
    #
    # ì•„ë˜ëŠ” ì¼íƒ€ì‹¸í”¼ì™€ í†µì‹ í•˜ëŠ” ë‚˜ë¨¸ì§€ ë¶€ë¶„ì´ë¯€ë¡œ ìˆ˜ì •í•˜ë©´ ì•ˆë©ë‹ˆë‹¤.
    ##############################

    merged_data = '%f/%f/' % (angle, power)
    sock.send(merged_data.encode('utf-8'))
    print('Data Sent: %s' % merged_data)

sock.close()
print('Connection Closed.\n--------------------')

```

## DFS 활용 문제
- matrix에서 0으로 묶여있는 덩어리들의 개수를 구하는 코드
``` python
N, M = map(int, input().split())

matrix = [list(map(int, input().split())) for _ in range(N)]


visited = [[0]*M for _ in range(N)]
cnt = 0

di = [1, -1, 0, 0]
dj = [0, 0, 1, -1]

for si in range(N):
    for sj in range(M):
        if matrix[si][sj] == 0 and visited[si][sj] == 0:
            cnt += 1
            visited[si][sj] = 1

            stack = [(si, sj)]
            while stack:
                i, j = stack.pop()

                for k in range(4):
                    ni, nj = i+di[k], j+dj[k]
                    if 0<=ni<N and 0<=nj<M:
                        if matrix[ni][nj] == 0 and visited[ni][nj] ==0:
                            visited[ni][nj] = 1
                            stack.append((ni, nj))

print(cnt)
```
## BFS 활용 문제
- 0: 괴물있음 1: 괴물없음
- 탈출하기 위해 움직여야 하는 최소 칸의 개수
``` python
N, M = map(int, input().split())
matrix = [list(map(int, input().split())) for _ in range(N)]
# N, M = 5, 6
# matrix = [[1, 0, 1, 0, 1, 0],
#           [1, 1, 1, 1, 1, 1],
#           [0, 0, 0, 0, 0, 1],
#           [1, 1, 1, 1, 1, 1],
#           [1, 1, 1, 1, 1, 1]]

start = (0, 0)
visited = [[0]*M for _ in range(N)]
visited[0][0] = 1
q = []
q.append(start)

while q:
    i, j = q.pop(0)

    if i == N-1 and j == M-1:
        print(visited[i][j])
        break

    for di, dj in [[1, 0], [-1, 0], [0, 1], [0, -1]]:
        ni, nj = i+di, j+dj
        if 0<=ni<N and 0<=nj<M:
            if matrix[ni][nj] == 1 and visited[ni][nj] == 0:
                visited[ni][nj] = visited[i][j] + 1
                q.append((ni, nj))
```

## 수행 시간 측정 소스코드 (시간복잡도)
``` python
import time
start_time = time.time() # 측정 시작

# 프로그램 소스코드
end_time = time.time() # 측정 종료
print("time :", end_time - start_time) # 수행 시간 출력
```

# 그리디
- 현재 상황에서 지금 당장 좋은 것만 고르는 방법

## 1. 거스름돈 문제: 거슬러 줘야 할 동전의 최소개수 (500원, 100원, 10원)
``` python

N_input = 1260

def money(data):
    A_500 = data // 500
    next = data % 500
    B_100 = next // 100
    next_next = next % 100
    C_10 = next_next / 10
    return int(sum([A_500, B_100, C_10]))

print(money(N_input))
```
``` python
n = 1260
count = 0

coin_types = [500, 100, 10]

for coin in coin_types:
    count += n // coin
    n = n% coin

print(count)
```

## 2. 큰 수의 법칙
``` python
N, M, K = map(int, input().split())
data = list(int, input().split())


# 가장 큰 수, 두 번째로 큰 수 찾기 (정렬함수 이용!!))
data.sort()
first_max = data[N - 1]
second_max = data[N - 2]

sum = ((M // K) * K * first_max) + ((M % K) * second_max) 
print(sum)
```

## 3. 숫자 카드 게임
``` python
n, m = map(int, input().split())

result = 0
# 한 줄씩 입력받아 확인
for i in range(n):
    data = list(map(int, input().split()))
    # 현재 줄에서 가장 작은 함수 찾기
    data.sort()
    min_value = data[0] # min_value = min(data)
    # 가장 작은 수들 중에서 가장 큰 수 찾기
    result = max(result, min_value)

print(result)
```

## 4. 1이 될 때까지
``` python
# n, k를 공백으로 구분하여 입력받기
n, k = map(int, input().split())
count = 0

while n != 1:   # while 문 활용하기!! 
    if n % k == 0:
        n = n / k
        count += 1
    else:
        n -= 1
        count += 1
print(count)
```
``` python
# N이 큰 수일때로 빠르게 동작하려면 N이 K의 배수가 되도록 한 번에 빼는 소스코드
n, k = map(int, input().split())
result = 0

while True:
    # (N == K로 나누어 떨어지는 수)가 될 때까지 1씩 빼기
    target = (n // k) * k
    result += (n-target)
    n = target
    # N이 K보다 작을 때(더 이상 나눌 수 없을 때) 반복문 탈출
    if n < k:
        break
    # K로 나누기
    result += 1
    n //= k

# 마지막으로 남은 수에 대하여 1씩 빼기
result += (n - 1)
print(result)
```

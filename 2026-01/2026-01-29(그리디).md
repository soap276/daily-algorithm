## 모험가 길드
``` python
N = int(input())
data = list(map(int, input().split()))

# N = 5
# data = [2, 3, 1, 2, 2]

data.sort()
count = 0 # 최대 그룹 수
i = 0 # 공포도가 가장 낮은 순부터 시작
while N - data[i] > 0: # 가장 낮은 공포도 크기로 그룹화
    count += 1 # 그룹 생성
    N -= data[i] # 전체 리스트 크기는 공포도만큼 작아짐
    i += data[i] # 다음 그룹 생성
print(count)
```
``` python
# 내가 푼 거 (틀림)
N = int(input())
data = list(map(int, input().split()))

N = 5
data = [2, 3, 1, 2, 2]


data.sort(reverse= True)
scale = int(data[0])
# print(scale)
list1 = []
while scale > 0:
    list1.append(data[scale - 1])
    scale -= 1
# print(list1)
next_scale = len(data) - data[0]
# print(next_scale)
list2 = []
data = data[data[0]:]
# print(data)
while next_scale > 0:
    list2.append(data[next_scale - 1])
    next_scale -= 1
# print(list2)
```

## 곱하기 혹은 더하기
- 왼쪽부터 + 혹은 x 연산을 수행할 때 가장 크게 나오는 결과 구하기
``` python
data = input()
# data = '02984'
data = list(data)

# 첫 번째 문자를 숫자로 변경하여 대입
sum = int(data[0])
for i in range(1, len(data)):
    num = int(data[i])
    # 두 수 중에서 하나라도 0 혹은 1인 경우, 곱하기보다는 더하기 수행
    if num <= 1 or sum <= 1:
        sum += num
    else:
        sum *= num
print(sum)
```

## 문자열 뒤집기
- 전부 0으로 바꾸는 경우와 전부 1로 바꾸는 경우 중에서 더 적은 횟수를 가지는 경우 계산
``` python
data = input()
# data = '0001100'

# 경우의 수는 2가지 
count0 = 0 # 모두 0으로 만들기
count1 = 0 # 모두 1으로 만들기

# 첫 번째 원소에 대해서 처리
if data[0] == '1':
    count0 += 1
else: 
    count1 += 1

# 두 번째 원소부터 모든 원소를 확인하며 진행
for i in range(len(data)-1):
    if data[i] != data[i+1]:
        # 다음 수에서 1로 바뀌는 경우
        if data[i+1] == '1':
            count0 += 1
        # 다음 수에서 0으로 바뀌는 경우
        else:
            count1 += 1

print(min(count0, count1))
```
